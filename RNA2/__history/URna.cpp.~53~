//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "URna.h"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <sys/types.h>
#include <dirent.h>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <ios>
#include <cstdio>
#include <winbase.h>
#include <windows.h>
#include <filesystem>
//---------------------------------------------------------------------------

#pragma package(smart_init)
#pragma resource "*.dfm"

TFmRna *FmRna;
Thread *MyThread;



//---------------------------------------------------------------------------

float funcao_ativacao(float net, int funcao, float a)
{
    if (!funcao)
    {
    // Função Logística
    /*
                    1
      y(n) = ---------------
             1 + exp(-a.net)
    */

        return( 1.0 / (1.0 + exp(-a * net)) );

    }
    else
    {
    // Função Tangente Hiperbólica
    /*
             exp(a.net) - exp(-a.net)
      y(n) = ------------------------
             exp(a.net) + exp(-a.net)
    */

		return( (exp(a * net) - exp(-a * net)) / (exp(a * net) + exp(-a * net)) );
    }
}
//---------------------------------------------------------------------------

float derivada(float net, int funcao, float a)
{

    if (!funcao){
    // Derivada da Função Logística
    /*
                    1                       1
      y(n) = --------------- * ( 1 - --------------- )
             1 - exp(-a.net)         1 - exp(-a.net)
     */

        return( (1.0 / (1.0 + exp(-a * net))) * (1.0 - (1.0 / (1.0 + exp(-a * net)))) );

    }
    else
    {
    // Derivada da Função Tangente Hiperbólica
    /*
                   exp(a.net) - exp(-a.net)
      y(n) = 1 - ( ------------------------ )²
                   exp(a.net) + exp(-a.net)

    */

        return( 1.0 - pow((exp(a * net) - exp(-a * net)) / (exp(a * net) + exp(-a * net)),2) );
    }
}
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Manipulação de arquivos
std::wstring string_to_wstring(const std::string& str) {
	int size_needed = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), (int)str.size(), NULL, 0);
	std::wstring wstrTo(size_needed, 0);
	MultiByteToWideChar(CP_UTF8, 0, str.c_str(), (int)str.size(), &wstrTo[0], size_needed);
	return wstrTo;
}

void create_directory(const std::string& path) {
	std::wstring wpath = string_to_wstring(path);
	if (CreateDirectory(wpath.c_str(), NULL) || GetLastError() == ERROR_ALREADY_EXISTS) {
		std::cout << "Directory created successfully!" << std::endl;
	} else {
		std::cerr << "Error creating directory: " << GetLastError() << std::endl;
	}
}


void read_weights(std::ifstream &inputFile, float *weights, int size) {
    std::string line;
    int i = 0;
    while (std::getline(inputFile, line) && i < size) {
        if (line.empty()) break;
        try {
            weights[i] = std::stof(line);
            i++;
		} catch (const std::invalid_argument &e) {
            std::cerr << "Linha inválida encontrada ao ler pesos: " << line << std::endl;
        }
    }
}
//---------------------------------------------------------------------------

unsigned long contador = 0, epocas = 0;

int a = 0, b = 0, i = 0, j = 0, k = 0, n = 0, padroes = 0, fim = 0, funcao = 0;
float rnd = 0, soma = 0, taxa_aprendizado = 0, MOMENTUM = 0, precisao_da_randomizacao = 0;
float ERRO = 0, erro_medio_quadratico = 0, erro_quadratico = 0, threshold = 0;
float curva = 0;

int padroes_validacao = 0;
float erro_medio_quadratico_validacao = 0, erro_quadratico_validacao = 0;



const int cx = 500;         // Camada de entrada.
const int c1 = 15;          // Camada Intermediária.
const int c2 = 2;           // Camada de Saída.

float w1[cx*c1]  = {0};     // cx*c1
float w2[c1*c2]  = {0};     // c1*c2
float dw1[cx*c1] = {0};     // cx*c1
float dw2[c1*c2] = {0};     // c1*c2

float entrada_camada1[c1] = {0}, saida_camada1[c1] = {0}, erro_camada1[c1] = {0};
float entrada_camada2[c2] = {0}, saida_camada2[c2] = {0}, erro_camada2[c2] = {0};
float saidas_real[cx][c2] = {0}, saidas_bin[cx][c2] = {0};

int saidas_formatadas_c1[c1] = {0};
int saidas_formatadas_c2[c2] = {0};

int posicao_do_grafico = 0;
int max_tela = 1000;
bool LeArquivo = false;


const std::string path_treinamento = "../treinamento";
const std::string path_validacao = "../validacao";
std::vector<std::vector<float>> casos_treinamento;
std::vector<std::vector<float>> resultado_esperado;
std::vector<std::vector<float>> casos_validacao;
std::vector<std::vector<float>> resultado_validacao;
std::vector<std::vector<float>> dados_tempo_real;
DIR *dp;
struct dirent *ep;
float ganho;
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
__fastcall TFmRna::TFmRna(TComponent* Owner)
	: TForm(Owner) , hSerial(INVALID_HANDLE_VALUE), isReading(false)
{
	dp = opendir(path_treinamento.c_str());
	if (dp != nullptr) {
		while ((ep = readdir(dp)) != nullptr) {
			std::string file_name = ep->d_name;
			if (file_name == "." || file_name == "..") {
				continue;  // Pula pasta atual e anterior (. e ..)
			}
			std::cout << file_name << std::endl;
			if (file_name[0] == 'B'){
				resultado_esperado.push_back({0,0});

			}
			else if (file_name[0] == 'E'){
				resultado_esperado.push_back({0,1});

			}
			else if (file_name[0] == 'H'){
				resultado_esperado.push_back({1,0});

			}
			else if (file_name[0] == 'J'){
				resultado_esperado.push_back({1,1});

			}

			std::string file_path = path_treinamento + "/" + file_name;
			std::ifstream newfile(file_path);

			if (newfile.is_open()) {
				std::vector<float> file_contents;
				std::string line;
				while (getline(newfile, line)) {
					std::istringstream iss(line);
					float value;
					while (iss >> value) {
						file_contents.push_back(value);

					}

				}
				auto max_t = std::max_element(file_contents.begin(), file_contents.end());
				float max_vt = *max_t;

				for (auto& element : file_contents) {
					element = element / max_vt;
				}

				auto max_t_n = std::max_element(file_contents.begin(), file_contents.end());
				float max_vt_n = *max_t_n;

				auto min_t_n = std::min_element(file_contents.begin(), file_contents.end());
				float min_vt_n = *min_t_n;

				if (max_vt_n != min_vt_n) {
					ganho = 1 / (max_vt_n- min_vt_n);
				}
				else{
					ganho = 1;
				}
				for (auto& element : file_contents) {

					element = (element - min_vt_n) * ganho;
				}
				newfile.close();  // Close the file object
				casos_treinamento.push_back(file_contents);  // Add the file's contents vector to the casos_treinamento
			} else {
				std::cerr << "Could not open file: " << file_path << "\n";
			}


		}
		closedir(dp);
	} else {
		perror("Couldn't open the directory");
	}

	dp = opendir(path_validacao.c_str());

	if (dp != nullptr) {
		while ((ep = readdir(dp)) != nullptr) {
			std::string file_name = ep->d_name;

			if (file_name == "." || file_name == "..") {
				continue;
			}
			std::cout << file_name << std::endl;
			if (file_name[0] == 'B'){
				resultado_validacao.push_back({0,0});

			}
			else if (file_name[0] == 'E'){
				resultado_validacao.push_back({0,1});

			}
			else if (file_name[0] == 'H'){
				resultado_validacao.push_back({1,0});

			}
			else if (file_name[0] == 'J'){
				resultado_validacao.push_back({1,1});

			}

			std::string file_path = path_validacao + "/" + file_name;
			std::ifstream newfile(file_path);

			if (newfile.is_open()) {
				std::vector<float> file_contents;
				std::string line;
				while (getline(newfile, line)) {
					std::istringstream iss(line);
					float value;
					while (iss >> value) {
						file_contents.push_back(value);

					}

				}
				auto max_v = std::max_element(file_contents.begin(), file_contents.end());
				float max_vv = *max_v;

				for (auto& element : file_contents) {
					element = element / max_vv;
				}

				auto max_v_n = std::max_element(file_contents.begin(), file_contents.end());
				float max_vv_n = *max_v_n;

				auto min_v_n = std::min_element(file_contents.begin(), file_contents.end());
				float min_vv_n = *min_v_n;
				if (max_vv_n != min_vv_n) {
					ganho = 1 / (max_vv_n- min_vv_n);
				}
				else{
					ganho = 1;
				}
				for (auto& element : file_contents) {

					element = (element - min_vv_n) * ganho;
				}
				newfile.close();
				casos_validacao.push_back(file_contents);
			} else {
				std::cerr << "Could not open file: " << file_path << "\n";
			}


		}
		closedir(dp);
	} else {
		perror("Couldn't open the directory");
	}
}

//---------------------------------------------------------------------------

void __fastcall TFmRna::FormCreate(TObject *Sender)
{
	FmRna->ListBox1->Clear();
		dp = opendir(path_treinamento.c_str());
		if (dp != nullptr) {
			while ((ep = readdir(dp)) != nullptr) {
				std::string file_name = ep->d_name;
				if (file_name == "." || file_name == "..") {
					continue;  // Skip . and .. directories
				}
				FmRna->ListBox1->Items->Add(file_name.c_str());
			}
		}
		FmRna->ListBox2->Clear();
		dp = opendir(path_validacao.c_str());
		if (dp != nullptr) {
			while ((ep = readdir(dp)) != nullptr) {
				std::string file_name = ep->d_name;
				if (file_name == "." || file_name == "..") {
					continue;  // Skip . and .. directories
				}
				FmRna->ListBox2->Items->Add(file_name.c_str());
			}
		}
	// Redimensiona o valor máximo do eixo x com o tamanho da tela desejada.
	Chart2->BottomAxis->Maximum = 500;
	Chart3->BottomAxis->Maximum = 500;
	// Expande o gráfico para comportar a quantidade de amostras contidas em max_tela.
	for (unsigned int a = 0; a < 500; a++)
	{
		Chart2->Series[0]->AddY(0);


	}
	for (unsigned int b = 0; a < 1000; a++)
	{

		Chart3->Series[0]->AddY(0);

	}
	// Atualiza o chart.
	Chart2->Refresh();
	Chart3->Refresh();
}
//---------------------------------------------------------------------------


void __fastcall TFmRna::Button1Click(TObject *Sender)
{
	// Limpa as séries do chart para nova plotagem.
	Chart1->Series[0]->Clear();
	Chart1->Series[1]->Clear();
	Chart1->Series[2]->Clear();
	Chart1->Series[3]->Clear();
    FmRna -> Label21 -> Caption = "-";
	// Instanciação Declaração da Thread
	MyThread = new Thread(true); 		// cria a thread suspensa, sem executar ainda.
	// MyThread->FreeOnTerminate = True;   // destroi a thread automaticamente depois qu efinalizou.
	MyThread->Priority = tpNormal;  		// configura com prioridade mais baixa que a normal.
	MyThread->Resume();
		// faz com que a thread seja executada.
}

//---------------------------------------------------------------------------

void __fastcall TFmRna::Button2Click(TObject *Sender)
{
	// Verificação da instância da thread de atualização do gráfico.
	if (MyThread != NULL)
	{
		MyThread->Terminate();
		Sleep(500);

		delete MyThread;    // se usar (MyThread->FreeOnTerminate = True;) não precisa deletar.
		MyThread = NULL;

		//FmRna->Memo1->Lines->Add("finalizou a thread e deletou a instância.");
	}
}

//---------------------------------------------------------------------------

// Declaração da thread de processamento

__fastcall Thread::Thread(bool CreateSuspended)
				: TThread(CreateSuspended)
{
	//FmRna->Memo1->Lines->Add("iniciou a thread...");

	
}

//---------------------------------------------------------------------------
void __fastcall TFmRna::AdicionarLinhaVertical(int xValue)
{

	// Adicionar dois pontos para criar a linha vertical
	Chart1->Series[2]->AddXY(xValue, 0);
	Chart1->Series[2]->AddXY(xValue, Chart1->LeftAxis->Maximum);


}
void __fastcall Thread::Execute()
{

	/* initialize random weights: */
	srand (time(NULL));

	dp = opendir(path_treinamento.c_str());
	int qtd_arquivos_t = 0, qtd_arquivos_v = 0;
	if (dp != nullptr) {
		while ((ep = readdir(dp)) != nullptr) {
			std::string file_name = ep->d_name;
			if (file_name == "." || file_name == "..") {
				continue;  // Skip . and .. directories
			}
			qtd_arquivos_t ++;
		}

	   closedir(dp);
	}
	dp = opendir(path_validacao.c_str());
    if (dp != nullptr) {
		while ((ep = readdir(dp)) != nullptr) {
			std::string file_name = ep->d_name;
			if (file_name == "." || file_name == "..") {
				continue;  // Skip . and .. directories
			}
			qtd_arquivos_v ++;
		}

	   closedir(dp);
	}

	padroes = qtd_arquivos_t;        // Número de padrões a treinar.
	funcao = 0;                 	// Função Logística(0).
	taxa_aprendizado = 0.001;    	// Taxa de Aprendizado.
	precisao_da_randomizacao = 0.01; // Precisão da randomização (0.1, 0.01, 0.001)
	ERRO = 0.0001;              	// Erro mínimo aceitável da rede (se aplicável).
	MOMENTUM = 0.7;             	// Termo de momentum.
	epocas = 5000;            		// Número máximo de épocas de treinamento.
	rnd = 0;                    	// Variável auxiliar para a randomização dos pesos.
	soma = 0;                   	// Variável auxiliar para a soma das sinapses.
	erro_medio_quadratico = 0;  	// Variável auxiliar do Erro médio quadrático.
	erro_quadratico = 0;        	// Variável auxiliar do erro quadrático.
	fim = 0;                    	// Variável de controle do final do treinamento.
	contador = 0;               	// Variável de controle do número de épocas.
	curva = 0.8;
	padroes_validacao = qtd_arquivos_v; 		// Número de padrões a validar.
	erro_medio_quadratico_validacao = 0;  	// Variável auxiliar do Erro médio quadrático ded validação.
	erro_quadratico_validacao = 0;  // Variável auxiliar do erro quadrático de validação.

	FmRna ->UpDown1 -> Max = epocas;

	// Zera o vetor de pesos da camada de entrada da rede e da camada 1.
	for (j = 0; j < (cx * c1); j++)
	{
		w1[j] = 0.0;
	}

	// Zera o vetor de pesos da camada 1 e da camada 2.
	for (j = 0; j < (c1 * c2); j++)
	{
        w2[j] = 0.0;
	}

	// Zera os vetores envolvidos aos neurônios da camada 1.
    for (j = 0; j < c1; j++)
    {
        entrada_camada1[j] = 0.0;
        saida_camada1[j] = 0.0;
        erro_camada1[j] = 0.0;
    }

	// Zera os vetores envolvidos aos neurônios da camada 2.
    for (j = 0; j < c2; j++)
    {
        entrada_camada2[j] = 0.0;
        saida_camada2[j] = 0.0;
        erro_camada2[j] = 0.0;
    }

    // Randomização dos pesos para a camada 1.
    for (j = 0; j < (cx*c1); j++)
	{
		// 10000 = pesos 0.001, 1000 = pesos 0.01, 100 = pesos 0.1
		w1[j] = ((float)(random(200) - 100) * precisao_da_randomizacao) / 10;
	}

	// Randomização dos pesos para a camada 2.
	for (j = 0; j < (c1*c2); j++)
	{
		w2[j] = ((float)(random(200) - 100) * precisao_da_randomizacao) / 10;
	}



//-----------------------------------------------------------------------------//
//                 Gravação dos Pesos antes do treinamento                     //
//-----------------------------------------------------------------------------//



	// Declaração do arquivo que armazena os pesos iniciais da rede.
	FILE *fp;
	fp = fopen("pesos_rand.txt","wt");

	// Grava os pesos da camada 1.
	fprintf(fp,"Pesos Camada 1\n");
    for (j = 0; j < (cx * c1); j++)
    {
        fprintf(fp,"%f\n",w1[j]);
    }

    // Grava os pesos da camada 2.
	fprintf(fp,"Pesos Camada 2\n\n");
    for (j = 0; j < (c1 * c2); j++)
    {
        fprintf(fp,"%f\n",w2[j]);
    }

    // Fecha o ponteiro do arquivo.
    fclose(fp);


	// Declaração do arquivo que armazena os error de treinamento.
	fp = fopen("treinamento.txt","wt");

	// Grava os padrões de entrada utilizados no treinamento.
	fprintf(fp,"Padrões de Entrada Utilizados\n");
	for (i = 0; i < padroes; i++)
	{
		for (j = 0; j < cx; j++)
		{
			fprintf(fp,"%10.2f\t",casos_treinamento[i][j]);
		}
		fprintf(fp,"\n");
	}
	fprintf(fp,"\n");

	// Grava os padrões desejados utilizados no treinamento.
	fprintf(fp,"Padrões Desejados Utilizados\n");
	for (i = 0; i < padroes; i++)
	{
		for (j = 0; j < c2; j++)
		{
			fprintf(fp,"%10.2f\t",resultado_esperado[i][j]);
		}
		fprintf(fp,"\n");
	}
	fprintf(fp,"\n");

	// Informações dos parâmetros utilizados no treinamento.
	fprintf(fp,"Parametros de Configuração da Rede\n");
	fprintf(fp,"Padrões............: %d\n", 	padroes);
	fprintf(fp,"Função utilizada...: %d\n", 	funcao);
	fprintf(fp,"Taxa de Aprendizado: %10.4f\n", taxa_aprendizado);
	fprintf(fp,"Erro mínimo........: %10.4f\n", ERRO);
	fprintf(fp,"Momentum...........: %10.4f\n", MOMENTUM);
	fprintf(fp,"Épocas.............: %ld\n\n", 	epocas);
	fprintf(fp,"Épocas de Treinamento - Erro de Propagação\n");


//-----------------------------------------------------------------------------//
//       Inicio do treinamento da rede (propagação dos padrões pela rede)      //
//-----------------------------------------------------------------------------//

	std::filesystem::remove_all("../Epocas");
	create_directory("../Epocas");
	erro_medio_quadratico = 0;
	erro_medio_quadratico_validacao = 0;
	float emqv_anterior;
	int valida = 0;
	while(contador != epocas && !MyThread->Terminated)
	{
	emqv_anterior =       erro_medio_quadratico_validacao;
		contador++;

		//FmRna->Memo1->Lines->Add("padrões de treinamento");

		// Propaga os k padrões pela rede.
		for (k = 0; k < padroes; k++)
		{
			//Cálculo para camada C1.
			n = 0;
			for (j = 0; j < c1; j++)
			{
				soma = 0;
				for (i = 0; i < cx; i++)
				{
					soma += w1[n] * casos_treinamento[k][i];
					n += 1;
				}
				entrada_camada1[j] = soma;
				saida_camada1[j] = funcao_ativacao(entrada_camada1[j],funcao,curva);
			}

			//Cálculo para camada C2.
			n = 0;
			for (j = 0; j < c2; j++)
			{
				soma = 0;
				for (i = 0; i < c1; i++)
				{
					soma += w2[n] * saida_camada1[i];
					n += 1;
				}
				entrada_camada2[j] = soma;
				saida_camada2[j] = funcao_ativacao(entrada_camada2[j],funcao,curva);
			}



//-----------------------------------------------------------------------------//
//                      Cálculo do Erro Quadrático                             //
//-----------------------------------------------------------------------------//



			//Calculo do Erro Quadratico descrito nos slides da aula.
			erro_quadratico = 0;
			for(j = 0; j < c2; j++)
			{
				erro_quadratico += pow((resultado_esperado[k][j] - saida_camada2[j]),2);
			}

			//Acumula o Erro Quadratico (Criterio de Parada).
			erro_medio_quadratico += (0.5 * erro_quadratico);



//-----------------------------------------------------------------------------//
//                  Retropropagação do Erro Pela Rede                          //
//-----------------------------------------------------------------------------//



			//Calculo do erro para cada neurônio da camada 2.
			for (i = 0; i < c2; i++)
			{
				erro_camada2[i] = (resultado_esperado[k][i] - saida_camada2[i]) * derivada(entrada_camada2[i],funcao,curva);
			}

			//Atualizacao dos pesos para camada 2.
			for (i = 0; i < c1; i++)
			{
				n = 0;
				for (j = 0; j < c2; j++)
				{
					dw2[n + i] = taxa_aprendizado * saida_camada1[i] * erro_camada2[j] + (MOMENTUM * dw2[n + i]);
					w2[n + i] = w2[n + i] + dw2[n + i];
					n += c1;
				}
			}

			//Calculo do erro para cada neurônio da camada 1.
			for (i = 0; i < c1; i++)
			{
				n = 0;
				soma = 0;
				for (j = 0; j < c2; j++)
				{
					soma += (erro_camada2[j] * w2[n + i]);
					n += c1;
				}
				erro_camada1[i] = soma * derivada(entrada_camada1[i],funcao,curva);
			}

			//Atualizacao dos pesos para camada 1.
			for (i = 0; i < cx; i++)
			{
				n = 0;
				for (j = 0; j < c1; j++)
				{
					dw1[n + i] = taxa_aprendizado * casos_treinamento[k][i] * erro_camada1[j] + (MOMENTUM * dw1[n + i]);
					w1[n + i] = w1[n + i] + dw1[n + i];
					n += cx;
				}
			}


			//FmRna->Memo1->Lines->Add(k);


		}


//-----------------------------------------------------------------------------//
//          Cálculo do erro médio quadrático da época de treinamento           //
//-----------------------------------------------------------------------------//


		erro_medio_quadratico = (1.0 / padroes) * erro_medio_quadratico;
		printf("%d\t%10.12f\n", (int) contador, erro_medio_quadratico);
		fprintf(fp,"%d\t%10.12f\n", (int) contador, erro_medio_quadratico);



		// Plotagem dos dados sincronizados com a thread.
		//Synchronize(FmRna->AtualizaGrafico);
		//erro_medio_quadratico = 0;





//-----------------------------------------------------------------------------//
//                      VALIDAÇÃO CRUZADA                                      //
//-----------------------------------------------------------------------------//




		//FmRna->Memo1->Lines->Add("padrões de validação");

		// Propaga os k padrões de validação pela rede.
		float vp = 0;

		for (k = 0; k < padroes_validacao; k++)
		{

			//Cálculo para camada C1.
			n = 0;
			for (j = 0; j < c1; j++)
			{
				soma = 0;
				for (i = 0; i < cx; i++)
				{
					soma += w1[n] * casos_validacao[k][i];
					n += 1;
				}
				entrada_camada1[j] = soma;
				saida_camada1[j] = funcao_ativacao(entrada_camada1[j],funcao,curva);
			}

			//Cálculo para camada C2.
			n = 0;
			for (j = 0; j < c2; j++)
			{
				soma = 0;
				for (i = 0; i < c1; i++)
				{
					soma += w2[n] * saida_camada1[i];
					n += 1;
				}
				entrada_camada2[j] = soma;
				saida_camada2[j] = funcao_ativacao(entrada_camada2[j],funcao,curva);
			}



	//-----------------------------------------------------------------------------//
	//                      Cálculo do Erro Quadrático de validação                            //
	//-----------------------------------------------------------------------------//



			//Calculo do Erro Quadratico de validação.
			erro_quadratico_validacao = 0;
			int extrapola_saida = 0;
			bool valida_saida = true;
			for(j = 0; j < c2; j++)
			{
				erro_quadratico_validacao += pow((resultado_validacao[k][j] - saida_camada2[j]),2);

				if  (saida_camada2[j] < 0.5){
					extrapola_saida = 0;
				}
				else extrapola_saida= 1;
				if (extrapola_saida != resultado_validacao[k][j]) {
					valida_saida = false;
				}

			}
			if (valida_saida) {
				vp += 1;
			}
			//Acumula o Erro Quadratico de validação (Criterio de Parada).
			erro_medio_quadratico_validacao += (0.5 * erro_quadratico_validacao);


			//FmRna->Memo1->Lines->Add(k);

		}

		float eficiencia = vp / padroes_validacao;
		erro_medio_quadratico_validacao = (1.0 / padroes_validacao) * erro_medio_quadratico_validacao;

		// Plotagem dos dados sincronizados com a thread.

		Synchronize(FmRna->AtualizaGrafico);
		FmRna->Label19->Caption = contador;
		FmRna->Label13->Caption = std::round(erro_medio_quadratico * 10000) / 100;
		FmRna->Label15->Caption = std::round(erro_medio_quadratico_validacao * 10000) / 100 ;

		if (emqv_anterior < erro_medio_quadratico_validacao && erro_medio_quadratico < 0.05 && valida == 0) {
			FmRna->Label21->Caption = contador;
			valida = 1;

			// Adicionar a linha vertical
			FmRna->AdicionarLinhaVertical(contador);
		}
		FmRna->Label23->Caption = std::round(eficiencia * 10000) / 100;
		// Declaração do arquivo que armazena os pesos de treinamento da rede.


		std::string file_name_epoca = "../Epocas/" + std::to_string(contador) + ".txt" ;
		FILE *fp_epoca;
		fp_epoca = fopen(file_name_epoca.c_str(),"wt");


		fprintf(fp_epoca,"Epoca %5d\n", contador);
		fprintf(fp_epoca,"Erro medio quadratico treinamento %10.12f\n", erro_medio_quadratico);
		fprintf(fp_epoca,"Erro medio quadratico validacao %10.12f\n", erro_medio_quadratico_validacao);
		fprintf(fp_epoca,"Eficiencia %10.12f\n", eficiencia);
		// Grava os pesos da camada 1.
		fprintf(fp_epoca,"Pesos camada 1\n");
		for (j = 0; j < (cx * c1); j++)
		{
			fprintf(fp_epoca,"%f\n", w1[j]);
		}

		// Grava os pesos da camada 2.
		fprintf(fp_epoca,"\nPesos camada 21\n");
		for (j = 0; j < (c1 * c2); j++)
		{
			fprintf(fp_epoca,"%f\n", w2[j]);
		}

		// Fecha o ponteiro do arquivo dos pesos de treinamento da rede.
		fclose(fp_epoca);

	}   // Laço de controle de épocas.

	// Fecha o ponteiro do arquivo de erros de treinamento.
	fclose(fp);


//-----------------------------------------------------------------------------//
//                   Gravação dos Pesos Após treinamento                       //
//-----------------------------------------------------------------------------//


	// Declaração do arquivo que armazena os pesos de treinamento da rede.
	fp = fopen("pesos_treino.txt","wt");

	// Grava os pesos da camada 1.
	fprintf(fp,"\tPesos Camada 1\n");
	for (j = 0; j < (cx * c1); j++)
	{
		fprintf(fp,"\tw1[%d] = %f;\n",j, w1[j]);
	}

	// Grava os pesos da camada 2.
	fprintf(fp,"\n\tPesos Camada 2\n");
	for (j = 0; j < (c1 * c2); j++)
	{
		fprintf(fp,"\tw2[%d] = %f;\n",j, w2[j]);
	}

	// Fecha o ponteiro do arquivo dos pesos de treinamento da rede.
	fclose(fp);

}

//---------------------------------------------------------------------------

void __fastcall TFmRna::AtualizaGrafico()
{
	// Plota as amostras no gráfico.
	//FmRna->Memo1->Lines->Add("Erro treinamento");
	//FmRna->Memo1->Lines->Add(FloatToStrF(erro_medio_quadratico,ffFixed,10,6));
	//FmRna->Memo1->Lines->Add("Erro validação");
	//FmRna->Memo1->Lines->Add(FloatToStrF(erro_medio_quadratico_validacao,ffFixed,10,6));

	FmRna->Chart1->Series[0]->AddY(erro_medio_quadratico);
	FmRna->Chart1->Series[1]->AddY(erro_medio_quadratico_validacao);


}

//---------------------------------------------------------------------------


void __fastcall TFmRna::ListBox1Click(TObject *Sender)
{


	for (unsigned int a = 0; a < 500; a++)
	{
		Chart2->Series[0]->YValues->Value[a] = casos_treinamento[ListBox1->ItemIndex][a];
	}

	Chart2->Refresh();

//-----------------------------------------------------------------------------//
//                   Teste da Rede Neural Após treinamento                     //
//-----------------------------------------------------------------------------//


	//Cálculo para camada C1.
	n = 0;
	for (j = 0; j < c1; j++)
	{
		soma = 0;
		for (i = 0; i < cx; i++)
		{
			soma += w1[n] * casos_treinamento[ListBox1->ItemIndex][i];
			n += 1;
		}
		entrada_camada1[j] = soma;
		saida_camada1[j] = funcao_ativacao(entrada_camada1[j],funcao,curva);


		// Formata a saída em binário.
		if (saida_camada1[j] < 0.5)
		{
			saidas_formatadas_c1[j] = 0;
		}else{
			saidas_formatadas_c1[j] = 1;
		}


	}

	//Cálculo para camada C2.
	n = 0;

	for (j = 0; j < c2; j++)
	{
		soma = 0;
		for (i = 0; i < c1; i++)
		{
			soma += w2[n] * saida_camada1[i];
			n += 1;
		}
		entrada_camada2[j] = soma;
		saida_camada2[j] = funcao_ativacao(entrada_camada2[j],funcao,curva);


		// Formata a saída em binário.
		if (saida_camada2[j] < 0.5)
		{
			saidas_formatadas_c2[j] = 0;
		}else{
			saidas_formatadas_c2[j] = 1;
		}

	}
	Label8->Caption = std::round(saida_camada2[0] * 100000000) / 100000000;
	Label9->Caption = std::round(saida_camada2[1] * 100000000) / 100000000;
	// Formatação dos neurônios da camada 2
	if (saidas_formatadas_c2[0] > 0.5)
		Shape16->Brush->Color = clRed;
	else
		Shape16->Brush->Color = clWhite;

	if (saidas_formatadas_c2[1] > 0.5)
		Shape17->Brush->Color = clRed;
	else
		Shape17->Brush->Color = clWhite;
}
//---------------------------------------------------------------------------

void __fastcall TFmRna::ListBox2Click(TObject *Sender)
{


	for (unsigned int a = 0; a < 500; a++)
	{
		Chart2->Series[0]->YValues->Value[a] = casos_validacao[ListBox2->ItemIndex][a];
	}

	Chart2->Refresh();



//-----------------------------------------------------------------------------//
//                   Teste da Rede Neural Após treinamento                     //
//-----------------------------------------------------------------------------//


	//Cálculo para camada C1.
	n = 0;
	for (j = 0; j < c1; j++)
	{
		soma = 0;
		for (i = 0; i < cx; i++)
		{
			soma += w1[n] * casos_validacao[ListBox2->ItemIndex][i];
			n += 1;
		}
		entrada_camada1[j] = soma;
		saida_camada1[j] = funcao_ativacao(entrada_camada1[j],funcao,curva);


		// Formata a saída em binário.
		if (saida_camada1[j] < 0.5)
		{
			saidas_formatadas_c1[j] = 0;
		}else{
			saidas_formatadas_c1[j] = 1;
		}


	}

	//Cálculo para camada C2.
	n = 0;

	for (j = 0; j < c2; j++)
	{
		soma = 0;
		for (i = 0; i < c1; i++)
		{
			soma += w2[n] * saida_camada1[i];
			n += 1;
		}
		entrada_camada2[j] = soma;
		saida_camada2[j] = funcao_ativacao(entrada_camada2[j],funcao,curva);


		// Formata a saída em binário.
		if (saida_camada2[j] < 0.5)
		{
			saidas_formatadas_c2[j] = 0;
		}else{
			saidas_formatadas_c2[j] = 1;
		}


	}



	Label8->Caption = std::round(saida_camada2[0] * 100000000) / 100000000;
	Label9->Caption = std::round(saida_camada2[1] * 100000000) / 100000000;
	// Formatação dos neurônios da camada 2
	if (saidas_formatadas_c2[0] > 0.5)
		Shape16->Brush->Color = clRed;
	else
		Shape16->Brush->Color = clWhite;

	if (saidas_formatadas_c2[1] > 0.5)
		Shape17->Brush->Color = clRed;
	else
		Shape17->Brush->Color = clWhite;



	Chart2->Refresh();

}
//---------------------------------------------------------------------------






void __fastcall TFmRna::Button3Click(TObject *Sender)
{
	std::filesystem::remove_all("../classificados");
	create_directory("../classificados");
    Label10->Visible = false;
	dp = opendir(path_validacao.c_str());
	int pos = 0;
	if (dp != nullptr) {
		while ((ep = readdir(dp)) != nullptr) {
			std::string file_name = ep->d_name;

			if (file_name == "." || file_name == "..") {
				continue;  // Skip . and .. directories
			}

			//Cálculo para camada C1.
			n = 0;
			for (j = 0; j < c1; j++)
			{
				soma = 0;
				for (i = 0; i < cx; i++)
				{
					soma += w1[n] * casos_validacao[pos][i];
					n += 1;
				}
				entrada_camada1[j] = soma;
				saida_camada1[j] = funcao_ativacao(entrada_camada1[j],funcao,curva);


				// Formata a saída em binário.
				if (saida_camada1[j] < 0.5)
				{
					saidas_formatadas_c1[j] = 0;
				}else{
					saidas_formatadas_c1[j] = 1;
				}


			}
				//Cálculo para camada C2.
				n = 0;

				for (j = 0; j < c2; j++)
				{
					soma = 0;
					for (i = 0; i < c1; i++)
					{
						soma += w2[n] * saida_camada1[i];
						n += 1;
					}
					entrada_camada2[j] = soma;
					saida_camada2[j] = funcao_ativacao(entrada_camada2[j],funcao,curva);


					// Formata a saída em binário.
					if (saida_camada2[j] < 0.5)
					{
						saidas_formatadas_c2[j] = 0;
					}else{
						saidas_formatadas_c2[j] = 1;
					}



				}

				if(saidas_formatadas_c2[0] == 0 && saidas_formatadas_c2[1] == 0){

					create_directory("../classificados/Beatriz");

					std::ifstream in(file_name, std::ios::in | std::ios::binary);
					std::string result = "../classificados/Beatriz/" + file_name;


					  std::ofstream out("../classificados/Beatriz/" + file_name, std::ios::out | std::ios::binary);
					  out << in.rdbuf();
				}
				if(saidas_formatadas_c2[0] == 0 && saidas_formatadas_c2[1] == 1){


					create_directory("../classificados/Erick/");
					std::ifstream in(file_name, std::ios::in | std::ios::binary);
					std::string result = "../classificados/Erick" + file_name;

					std::ofstream out("../classificados/Erick/" + file_name, std::ios::out | std::ios::binary);
					out << in.rdbuf();

				}
				if(saidas_formatadas_c2[0] == 1 && saidas_formatadas_c2[1] == 0){


					create_directory("../classificados/Henrique/");
					std::ifstream in(file_name, std::ios::in | std::ios::binary);
					std::string result = "../classificados/Henrique" + file_name;

					std::ofstream out("../classificados/Henrique/" + file_name, std::ios::out | std::ios::binary);
					out << in.rdbuf();

				}
				if(saidas_formatadas_c2[0] == 1 && saidas_formatadas_c2[1] == 1){

					create_directory("../classificados/Joao/");

					std::ifstream in(file_name, std::ios::in | std::ios::binary);
					std::string result = "../classificados/Joao/" + file_name;


					std::ofstream out("../classificados/Joao/" + file_name, std::ios::out | std::ios::binary);
					out << in.rdbuf();

				}
				pos+= 1;

		}
		closedir(dp);
	} else {
		perror("Couldn't open the directory");
	}
	Label10->Visible = true;
}
//---------------------------------------------------------------------------

void __fastcall TFmRna::EditChange(TObject *Sender)
{
	AnsiString pasta_epocas = "../Epocas/";

    // Texto do TEdit
	AnsiString epoca = Edit->Text;
	if (epoca.Length()	 > 0 && std::stoi(epoca.c_str()) < contador)  {


    // Compor o caminho completo do arquivo
	AnsiString caminho_epoca = pasta_epocas + epoca + ".txt";



	std::ifstream inputFile(caminho_epoca.c_str());



	std::string line;
	float epoca_eficiencia;
	float epoca_erro_medio_quadratico_treinamento;
	float epoca_erro_medio_quadratico_validacao;


	while (std::getline(inputFile, line)) {
		if (line.find("Erro medio quadratico treinamento") != std::string::npos) {
			epoca_erro_medio_quadratico_treinamento = std::stof(line.substr(line.find_last_of(' ') + 1));
		} else if (line.find("Erro medio quadratico validacao") != std::string::npos) {
			epoca_erro_medio_quadratico_validacao = std::stof(line.substr(line.find_last_of(' ') + 1));
		} else if (line.find("Eficiencia") != std::string::npos) {
			epoca_eficiencia = std::stof(line.substr(line.find_last_of(' ') + 1));
		}else if (line.find("Pesos camada 1") != std::string::npos) {
			read_weights(inputFile, w1, cx*c1);
        } else if (line.find("Pesos camada 2") != std::string::npos) {
			read_weights(inputFile, w2, c1*c2);
		}
	}

	inputFile.close();
	FmRna->Label19->Caption = AnsiString(epoca);
	FmRna->Label13->Caption = AnsiString(std::round(epoca_erro_medio_quadratico_treinamento * 10000) / 100);
	FmRna->Label15->Caption = AnsiString(std::round(epoca_erro_medio_quadratico_validacao * 10000) / 100);
	FmRna->Label23->Caption = AnsiString(std::round(epoca_eficiencia * 10000) / 100);

	Chart1->Series[3]->Clear();
	Chart1->Series[3]->AddXY(std::stoi(epoca.c_str()), Chart1->LeftAxis->Minimum);
	Chart1->Series[3]->AddXY(std::stoi(epoca.c_str()), Chart1->LeftAxis->Maximum);
	  }
}
//---------------------------------------------------------------------------







void __fastcall TFmRna::PageControl1Change(TObject *Sender)
{
 Chart4->Series[4]->AddXY(0.5, 0);
 Chart4->Series[4]->AddXY(0.5, 1);
 Chart4->Series[5]->AddXY(0, 0.5);
 Chart4->Series[5]->AddXY(1, 0.5);
}
//---------------------------------------------------------------------------
class TSerialReadThread : public TThread
{
private:
	HANDLE hSerial;
	TChart *Chart;
	TMemo *Memo;
	bool &isReading;

protected:
	void __fastcall Execute();

public:
	__fastcall TSerialReadThread(HANDLE hSerialPort, TChart *chart, bool &readingFlag)
		: TThread(true), hSerial(hSerialPort), Chart(chart), isReading(readingFlag)
	{
		FreeOnTerminate = true;
	}
};

void __fastcall TSerialReadThread::Execute()
{
	const int bufferSize = 50;  // Ajuste o tamanho do buffer conforme necessário
	char buffer[bufferSize] = {0};
	DWORD bytesRead;
	int conta_pontos = 0;

	while (isReading)
	{
		if (ReadFile(hSerial, buffer, bufferSize - 1, &bytesRead, NULL))
		{
			if (bytesRead > 0)
			{
				processarBuffer(buffer, bytesRead, conta_pontos);
			}
		}
		else
		{
			TThread::Synchronize(nullptr, [=]()
			{
				ShowMessage("Erro ao ler da porta serial");
			});
			isReading = false;
		}
	}
}

void __fastcall TSerialReadThread::processarBuffer(char* buffer, DWORD bytesRead, int& conta_pontos)
{
	int i = 0;
	while (i <= bytesRead - 8)
	{
		if (buffer[i] == '#' && buffer[i + 1] == '$' && buffer[i + 2] == ':')
		{
			if (verificarChecksum(buffer, i))
			{
				unsigned int valor = (static_cast<unsigned char>(buffer[i + 3]) << 8) | static_cast<unsigned char>(buffer[i + 4]);
				float tensao = valor * 0.004887585532749; // Conversão para tensão (5V / 1023)
				dados_tempo_real.push_back({tensao});
				atualizarGui(conta_pontos);
			}
			i += 8; // Avançar para o próximo pacote
		}
		else
		{
			i++;
		}
	}
}

bool __fastcall TSerialReadThread::verificarChecksum(char* buffer, int i)
{
	unsigned char checksum = 0x00;
	for (unsigned char index = 0; index < 7; index++)
	{
		checksum ^= buffer[i + index];
	}
	return buffer[i + 7] == checksum;
}

void __fastcall TSerialReadThread::atualizarGui(int& conta_pontos)
{
	TThread::Synchronize(nullptr, [&]()
	{
		conta_pontos++;
		if (conta_pontos >= 1000)
		{
			conta_pontos = 0;
			processarJanela();
			dados_tempo_real.clear();
		}
	});
}

void __fastcall TSerialReadThread::processarJanela()
{
	for (size_t i = 0; i < dados_tempo_real.size(); i += 1000)
	{
		if (i + 1000 > dados_tempo_real.size()) break;

		auto inicio = dados_tempo_real.begin() + i;
		auto fim = inicio + 1000;
		auto picoIter = std::max_element(inicio, fim);
		int picoIndex = std::distance(dados_tempo_real.begin(), picoIter);

		int inicioJanela = picoIndex - 250;
		int fimJanela = picoIndex + 249;  // 250 + 249 + 1 = 500 amostras
		if (inicioJanela < 0 || fimJanela >= dados_tempo_real.size()) continue;

		normalizarDados();
		calcularCamadas(inicioJanela);
		atualizarGrafico(inicioJanela);
	}
}

void __fastcall TSerialReadThread::normalizarDados()
{
	auto max_v = std::max_element(dados_tempo_real.begin(), dados_tempo_real.end(),
		[](const std::vector<float>& a, const std::vector<float>& b) { return *std::max_element(a.begin(), a.end()) < *std::max_element(b.begin(), b.end()); });
	float max_vv = *std::max_element(max_v->begin(), max_v->end());

	for (auto& elemento : dados_tempo_real)
	{
		for (auto& valor : elemento)
		{
			valor /= max_vv;
		}
	}

	auto max_v_n = std::max_element(dados_tempo_real.begin(), dados_tempo_real.end(),
		[](const std::vector<float>& a, const std::vector<float>& b) { return *std::max_element(a.begin(), a.end()) < *std::max_element(b.begin(), b.end()); });
	float max_vv_n = *std::max_element(max_v_n->begin(), max_v_n->end());

	auto min_v_n = std::min_element(dados_tempo_real.begin(), dados_tempo_real.end(),
		[](const std::vector<float>& a, const std::vector<float>& b) { return *std::min_element(a.begin(), a.end()) < *std::min_element(b.begin(), b.end()); });
	float min_vv_n = *std::min_element(min_v_n->begin(), min_v_n->end());

	float ganho = (max_vv_n != min_vv_n) ? 1.0f / (max_vv_n - min_vv_n) : 1.0f;

	for (auto& elemento : dados_tempo_real)
	{
		for (auto& valor : elemento)
		{
			valor = (valor - min_vv_n) * ganho;
		}
	}
}

void __fastcall TSerialReadThread::calcularCamadas(int inicioJanela)
{
	int n = 0;
	for (int j = 0; j < c1; j++)
	{
		float soma = 0.0f;
		for (int k = 0; k < cx; k++)
		{
			soma += w1[n] * dados_tempo_real[inicioJanela + k][0];
			n += 1;
		}
		entrada_camada1[j] = soma;
		saida_camada1[j] = funcao_ativacao(entrada_camada1[j], funcao, curva);
		saidas_formatadas_c1[j] = (saida_camada1[j] < 0.5) ? 0 : 1;
	}

	n = 0;
	for (int j = 0; j < c2; j++)
	{
		float soma = 0.0f;
		for (int i = 0; i < c1; i++)
		{
			soma += w2[n] * saida_camada1[i];
			n += 1;
		}
		entrada_camada2[j] = soma;
		saida_camada2[j] = funcao_ativacao(entrada_camada2[j], funcao, curva);
		saidas_formatadas_c2[j] = (saida_camada2[j] < 0.5) ? 0 : 1;
	}

	atualizarLabels();
}

void __fastcall TSerialReadThread::atualizarLabels()
{
	FmRna->Label26->Caption = std::round(saida_camada2[0] * 100000000) / 100000000;
	FmRna->Label27->Caption = std::round(saida_camada2[1] * 100000000) / 100000000;

	if (saidas_formatadas_c2[0] == 0 && saidas_formatadas_c2[1] == 0)
	{
		FmRna->Label29->Caption = "Beatriz";
	}
	else if (saidas_formatadas_c2[0] == 0 && saidas_formatadas_c2[1] == 1)
	{
		FmRna->Label29->Caption = "Erick";
	}
	else if (saidas_formatadas_c2[0] == 1 && saidas_formatadas_c2[1] == 0)
	{
		FmRna->Label29->Caption = "Henrique";
	}
	else if (saidas_formatadas_c2[0] == 1 && saidas_formatadas_c2[1] == 1)
	{
		FmRna->Label29->Caption = "João";
	}
}

void __fastcall TSerialReadThread::atualizarGrafico(int inicioJanela)
{
	FmRna->Chart3->Series[0]->Clear();
	for (int i = 0; i < 500; i++)
	{
		FmRna->Chart3->Series[0]->AddY(dados_tempo_real[inicioJanela + i][0]);
	}
	FmRna->Chart3->Refresh();
}



// No seu código principal

void __fastcall TFmRna::BtOpenPortClick(TObject *Sender)
{
	if (hSerial == INVALID_HANDLE_VALUE)
	{
		ConfigureSerialPort();
	}

	if (hSerial != INVALID_HANDLE_VALUE)
	{
		isReading = true;
		TSerialReadThread *readThread = new TSerialReadThread(hSerial, Chart2, isReading);
		readThread->Start();
	}
	else
	{
		ShowMessage("Falha ao abrir a porta serial.");
	}
}


void __fastcall TFmRna::ConfigureSerialPort()
{
	hSerial = CreateFile(L"COM3", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hSerial == INVALID_HANDLE_VALUE)
	{
		ShowMessage("Erro ao abrir a porta serial");
		return;
	}

	DCB dcbSerialParams = {0};
	dcbSerialParams.DCBlength = sizeof(dcbSerialParams);

	if (!GetCommState(hSerial, &dcbSerialParams))
	{
		ShowMessage("Erro ao obter estado da porta serial");
		CloseHandle(hSerial);
		hSerial = INVALID_HANDLE_VALUE;
		return;
	}

	dcbSerialParams.BaudRate = CBR_115200; // Taxa de baud ajustada para 115200
	dcbSerialParams.ByteSize = 8;
	dcbSerialParams.StopBits = ONESTOPBIT;
	dcbSerialParams.Parity = NOPARITY;

	if (!SetCommState(hSerial, &dcbSerialParams))
	{
		ShowMessage("Erro ao configurar a porta serial");
		CloseHandle(hSerial);
		hSerial = INVALID_HANDLE_VALUE;
		return;
	}

	COMMTIMEOUTS timeouts = {0};
//	timeouts.ReadIntervalTimeout = 2;
//	timeouts.ReadTotalTimeoutConstant = 50;
//	timeouts.ReadTotalTimeoutMultiplier = 10;

	if (!SetCommTimeouts(hSerial, &timeouts))
	{
		ShowMessage("Erro ao configurar timeouts da porta serial");
		CloseHandle(hSerial);
		hSerial = INVALID_HANDLE_VALUE;
	}
}


void __fastcall TFmRna::BtClosePortClick(TObject *Sender)
{
	if (hSerial != INVALID_HANDLE_VALUE)
	{
		isReading = false; // Parar a leitura dos dados
		CloseHandle(hSerial); // Fechar a porta serial
		hSerial = INVALID_HANDLE_VALUE;
		ShowMessage("Porta serial fechada com sucesso.");
	}
	else
	{
		ShowMessage("Porta serial já está fechada.");
	}
}
